<3장 : R에서 데이터 다루기>


3.1 벡터 다루기


3.1.1 새 벡터 변수 만들기 

① 벡터에 데이터 추가 및 벡터들의 결합 : 함수 c()

x=c(1,2,3,4)
x=c(x,5) #입력한 벡터에 데이터 추가로 입력
x 

y=c(6,7,8)
x=c(x,y) #기존 벡터 x에 벡터 y 결합
x

벡터에 데이터를 추가하는 작업은 대괄호 이용도 가능

x
x[length(x)+1]=9 #length(x) : 벡터의 길이 함수, 대괄호 / []: 벡터 인덱싱
x

② 일정한 구조를 갖는 벡터의 생성

1)콜론(:) : 연산자

a:b : a>b일때 1씩 증가하는 수열, a<b이면 1씩 감소하는 수열

1:5 #1~5까지 나열
-3:3
1.5:5.4 #간격을 설정하지 않았을 때 간격은 1
5:0

2)함수 seq()

seq(from=0,to=5) #0:5와 동일, seq(0,5)와 동일
seq(0,5,by=2) #옵션 by : 증가 폭 조절
seq(0,5,length=3) #옵션 length : 수열의 길이 지정

3,)함수 rep() #반복 함수
.
rep(1,times=5) #rep(1,5)와 동일
rep(c(1,3,5),2) #벡터 c(1,3,5)를 2회 반복
rep(c("M","F"),c(2,3)) #M을 2번 F를 3번 반복

★③벡터의 자료수정과 추가 - 후에 자세한 설명

ebay=c(88.8,88.3,90.2,93.5,95.2,94.7,99.2,99.4,101.6)
ebay[1]
ebay[1:4]
ebay[c(1,5,9)]

ebay[1]
ebay[10:13]=c(97.0,99.3,102.0,101.8) #10~13번째 수 추가
ebay

④ 벡터의 연산 : 벡터와 벡터의 연산은 대응되는 각 구성요소끼리의 연산, 즉 벡터 단위로 이루어진다.

x=c(7,8,9,10)
y=c(1,2,3,4)
x+y
x-y
x*y
x/y
x^y

벡터와 스칼라의 연산도 동일한 개념으로 실행(대응되는 구성요소끼리의 연산)

x
x+3
x/4
2^x

⑤ 벡터 연산의 순환법칙 : 벡터와 벡터의 연산은 대응되는 요소끼리의 연산

만일 두 벡터의 길이가 달라 일대일 대응이 이루어지지 않을 경우
길이가 짧은 벡터를 순환반복시켜 길이를 동일하게 만든 후 연산을 진행한다.

c(1,2,3,4,5,6)+c(1,2,3) #c(1,2,3)을 순환반복

벡터와 스칼라 간의 연산도 동일 법칙 적용

긴 벡터의 길이가 짧은 벡터 길이의 배수가 되지 않는 경우에는 두 벡터의 길이를 동일하게 만들 수 없다

c(1,2,3,4)+c(1,2,3)

> 순환법칙을 의도적으로 사용하지 않은 경우에 경고문구를 보게되었을 경우 연산 오류일 가능성이 높으니
반드시 연산과정 확인하기


3.1.2 숫자형 벡터와 문자형 벡터를 위한 다양한 함수

① 수학 관련 함수

abs(-2) #절대값 계산
sqrt(25) #제곱근 계산
ceiling(3.475) #()안의 숫자보다 작지 않은 가장 작은 정수
floor(3.475) #()안의 숫자보다 크지 않은 가장 큰 정수
trunc(5.99) #소수점 이하 버림
round(3.475,2) #소수 2자리로 반올림
signif(0.00347,2) #유효수 2자리로 반올림

sin(1);cos(1);tan(1) #삼각함수
asin(sin(1));acos(cos(1));atan(tan(1)) #역삼각함수
log(2,base=2) #옵션 base : 로그함수의 밑
log(10) #자연로그
exp(log(10)) #지수함수, 자연로그의 역함수

② 통계관련 함수

x=c(1,2,3,4,50)

mean(x) #평균
median(x) #중간값
range(x) #범위
IQR(x) #제3사분위수-제1사분위수
sd(x) #표준편차
var(x) #분산
sum(x) #총합
min(x) #최솟값
max(x) #최댓값
diff(x) #n차 차분 : diff(x, lag=n)

★③ 문자함수

1)nchar() : 문자열 x를 구성하는 문자의 개수

x=c("Park","Lee","Kwon")
nchar(x)

2)paste() : 문자열의 결합

paste("모든","사람은","통계학을","좋아한다") #디폴드 옵션 sep=" " / 옵션 sep : 문자열 사이에 삽입되는 값
paste("모든","사람은","통계학을","좋아한다",sep="-")
paste("모든","사람은","통계학을","좋아한다",sep="")

문자열과 숫자의 결합도 가능하다

paste("원주율은",pi,"이다")
paste("Stat",1:3,sep="")

==================================================(여기부터 기말고사)

3)substr() : 주어진 문자열의 일부분을 선택함

substr(문자열,시작점,끝점)

substr("Statistics",1,4)
substr("Statistics",7,9)

y=c("정보통계학과","응용통계학과")
substr(y,3,6) #문자열 벡터 y의 모든 문자열의 3~6번 요소 출력
substr(y,c(1,3),c(2,6)) #첫번째 문자열의 1~2, 두번째 문자열의 3~6번 출력

3-ex)문자형 벡터 cities에는 미국의 세 도시와 그 도시가 속한 주 이름이 입력

cities=c("NewYork,NY","AnnArbor,MI","Chicago,IL")
states=substr(cities,nchar(cities)-1,nchar(cities)) #세 도시가 속한 주 이름만을 입력하여 states라는 문자형 벡터에 할당
states

4)toupper() : 대문자로 수정
tolower() : 소문자로 수정

x=c("Park","Lee","Kwon")

toupper(x)
tolower(x)

5)strsplit() : 문자열의 분리

cities=c("NewYork,NY","AnnArbor,MI","Chicago,IL")
city=strsplit(cities,split=",") #옵션 split에 기재한 값을 기준으로 주어진 문자열 분리
city

세 도시가 속한 주 이름만을 선택하기
c(city[[1]][2],city[[2]][2],city[[3]][2])

strsplit("PARK",split="") #문장열을 구성하는 모든 문자의 분리

6)함수 sub(),gsub() : 문자열의 치환

sub(old,new,문자열) : 문자열의 첫번째 old값만 new로 치환
gsub(old,new,문자열) : 문자열의 모든 old가 new로 치환

x="Park hates stats. He hate math, too"
sub("hat","lov",x)
gsub("hat","lov",x)

문자열의 일부 삭제는 new값에 ""입력

y="Everybody cannot do it"

sub("not","",y)


3.1.3 벡터의 비교

벡터의 인덱싱 혹은 벡터의 변환에 필수적인 요소

☆★연산자

비교연산자

< : 작다
<= : 작거나 같다
> : 크다
>= : 크거나 닥타
== : 같다 ("="와 헷갈리지 않도록 주의!, =는 문자열을 동일하게 만들고 ==는 비교연산자)
!= : 같지 않다

논리연산자

!x : x가 아니다 (NOT)
x|y : x 또는 y (OR) #특수문자 ㄱ+한자 (쉬프트+\)
x&y : x 그리고 y (AND)

x=c(3,8,2)
y=c(5,4,2)

x>y
x>=y
x<y
x<=y
x==y
x!=y

벡터와 스칼라의 비교는 순환법칙이 적용됨

x=1:3
x>2
x<2
x<=2|x>=3
x<=2&x>=1

※각 요소끼리의 비교걸과 보다는 벡터 전체의 비교 결과를 원하는 경우

all() : 모든 요소는 ()내 연산자를 만족한다
any() : 벡터 내 적어도 1개의 요소는 ()내 연산자를 만족한다

x=1:9

all(x==5)
any(x==5)

☆논리형 백터의 숫자형 벡터로의 전환

x=1:5
x>=4

sum(x>=4) #연산을 만족하는 숫자의 갯수 (TRUE=1)
length(x[x>=4]) #연산을 만족하는 숫자의 길이 (위의 수식과 동일한 의미)

mean(x>=4) #연산을 만족하는 숫자의 비율 (TRUE=1)
length(x[x>=4])/length(x)


★3.1.4 벡터의 인덱싱

대괄호에 색인(index) 직접 지정

양수 색인 : 해당 요소 선택
음수 색인 : 해당 요소 제외

x=c(80,88,90,93,95,94,99,78,101)
x[c(1,3,4)]
x[1:3]
x[-(1:3)] #1~3번째 요소 삭제 후 인덱싱

논리형 벡터에 의한 색인 지정 (연산자 사용)

x=c(80,88,90,93,95,94,99,78,101)

x>=mean(x)
x[x>=mean(x)] #위 기준을 만족하는 요소만 인덱싱

☆★예제) 

x=c(80,88,90,93,95,94,99,78,101)

1. 평균으로부터 ±1 표준편차 안에 있는 관찰값

z=(x-mean(x))/sd(x)
x[abs(z)<=1]

2. 평균으로부터 ±1 표준편차와 ±2 표준편차 사이에 있는 관찰값

x[abs(z)>1&abs(z)<=2]

3. 평균으로부터 ±2 표준편차를 벗어나는 관찰값

x[abs(z)>2]


☆★3.1.5 변수 변환

연속형 변수 -> 범주형 변수로 변환

1)논리형 벡터 이용

x=c(80,88,90,93,95,94,99,78,101)

cat.x=(x>=min(x))+(x>=90)+(x>=100) #cat() : 문자열을 별도의 ""없이 그대로 출력하는 함수(이 수식에선 쓰일 일 없으나 cat함수가 나와서 씀

factor(cat.x) #factor : 범주형(요인) 변수 함수

cat.x=factor(cat.x,labels=c("C","B","A"))
data.frame(x,cat.x) #데이터 프레임 생성

2)함수 cut() 이용

cat.x=cut(x, breaks=c(min(x),90,100,max(x)),include.lowest=TRUE,right=FALSE,labels=c("C","B","A"))
cat.x

> 나눈 구간에 해당될때 TRUE(=1) 아닐때 FALSE(=0)

#옵션 breaks : 구간의 최소값, 최대값을 포함한, 구간 설정 벡터, 최솟값~90/90~100/100~최댓값 구간으로 분리
#옵션 right : 구간이 a<x≤b이면 TRUE, a≤x<b이면 FALSE
#옵션 include.lowest : 구간의 최소값(right=TRUE일때)또는 최대값(right=FALSE일때)과 같은 관찰값도 변환에 포함시킬지 여부 결정
     -> include.lowest=T min≤x≤b (right=TRUE) / a≤x≤max (right=FALSE)
#옵션 labels : 수준(level)의 라벨(이름) 지정

p.115

문제 5.


☆★3.1.6 결측값

결측값 기호 : NA (not avaliable)

데이터에 결측값 포함여부 확인 : 함수 is.na()

x=c(1,0,3,5,NA)
is.na(x) #논리형 함수

x==NA #결측값은 자기 자신을 포함한 어느 요소와도 비교가 불가하다

NA가 호함된 데이터의 연산 결과 : 측정 불가

x=c(1,0,3,5,NA)
mean(x);max(x) 

※연산에서 NA를 제거하는 방법 : 옵션 na.rm=TRUE 추가

mean(x,na.rm=TRUE);max(x,na.rm=TRUE)


[유용한 정보]

① 데이터 객체의 유형 전환 함수

유형 확인

is.numeric()
is.character()
is.vector()
is.factor()
is.matrix()
is.data.frame()

유형 전환

as.numeric()
as.chracter()
as.vector()
as.factor()
as.matrix()
as.data.frame()

x=c(1,1,2,3,2);is.numeric(x)

f.x=factor(x);is.factor(f.x)
f.x

as.numeric(f.x)

is.numeric(as.numeric(f.x))

② 연산자 우선순위

ex)0부터 n-1까지의 정수 표현

n=5
0:n-1 #잘못된 표현! 콜론(:)기호의 경우 빼기연산자보다 우선순위이다 그래서 (0:n)-1로 계산됨
0:(n-1) #과 같이 계산해주어야 정상적으로 출력

※각 연산자의 우선순위(위로 갈수록 높은 우선순위를 갖고있다)

[], [[]] #인덱싱
$ #인덱싱
^ #지수
: #콜론 연산자(수열)
%any% #특별 연산자 ☆뒷부분 참조
*, / #곱하기, 나누기
==, !=, <, >, <=, >= #비교 연산자
! #논리 연산자 NOT
&, && #논리 연산자 AND
|, || #논리 연산자 OR
~ #공식(FORMULA)
=, <- #할당

☆%any% 연산자

%% : 나머지, 나누기 연산자
%/% : 몫, 나누기 연산자
%*% : 행렬의 곱하기 연산자
%in% : 데이터에 특정 값의 포함여부 확인


★3.2 행렬다루기

행렬, 배열 생성함수(2장) 복습!
행렬 생성 : 함수 matrix()와 다른 방식으로 생성
> 함수 cbind(), rbind()

x1=c(1,2,3);x2=c(4,5,6);x3=c(7,8,9)
A=cbind(x1,x2,x3) #벡터의 열 결합
B=rbind(x1,x2,x3) #벡터의 행 결합
A
B

cbind와 rbind는 순환법칙이 적용된다

x1=c(1,2,3,4);x2=c(4,5);x3=7

cbind(x1,x2,x3)

rbind(x1,x2,x3)

행과 열에 라벨링, dimnames와 다른 방식으로 라벨링
> 함수 rownames(), colnames()

A=matrix(1:9,nrow=3)
A

rownames(A)=paste("R",1:3,sep="")
colnames(A)=paste("C",1:3,sep="")
A

★행렬의 인덱싱

A[1,3] #색인 입력
A["R1","C3"] #라벨 입력


☆★3.2.1 행렬의 연산 (여기서부터 핵중요!)

선형대수 및 다양한 통계 분석에서 사용됨

예시) A,B : 행렬; x,b : 벡터; k : 스칼라

[연산자 및 함수의 기능 정리]

+, -, *, /, ^ : 행렬을 구성하는 숫자 각각에 적용된다
A%*%B : 행렬 곱
cbind(A,B,...) : 행렬 또는 벡터를 열단위로 결합
colMeans(A) : 행렬 A의 각 열의 평균값으로 구성된 벡터
crossprod(A) : t(A)%*%A #A의 전치와 A의 행렬 곱
crossprod(A,B) : t(A)%*%B 
colSums(A) : 행렬 A의 각 열의 합으로 구성된 벡터
diag(A) : 행렬 A의 주대각선 원소로 구성된 벡터
diag(x) : 벡터 x를 주대각선 원소로 하는 대각행렬
diag(k) : k*k 단위행렬
eigen(A) : 행렬 A의 고유값과 고유벡터로 구성된 리스트
rbind(A,B,...) : 행렬 또는 벡터를 행단위로 결합
rowMeans(A) : 행렬 A의 각 행의 평균값으로 구성된 벡터
rowSums(A) : 행렬 A의 각 행의 합으로 구성된 벡터
solve(A) : 행렬 A의 역행렬
solve(A,b) :  연립방정식 Ax=b의 해
t(A) : 행렬 A의 전치 행렬
tcrossprod(A) : A%*%t(A)
tcrossprod(A,B) : A%*%t(B)

>적용

A=matrix(1:4,2,byrow=T) #옵션 byrow : 행 기준으로 행렬생성
B=matrix(5:8,2,byrow=T)
A
B
A*B
A%*%B
crossprod(A,B)
t(A)%*%B #위와 동일
cbind(A,B)
rbind(A,B)
colMeans(A)
rowSums(A)
diag(A)
diag(2)
solve(A)
solve(A)%*%A

b=c(5,6);solve(A,b)
#함수 x+2y=5;3x+4y=6 연립방정식의 해

p.116

문제 7.


3.2.2 행과 열 단위로 행렬에 함수 적용

apply()
apply(행렬,1,함수) : 행 단위로 행렬에 함수 적용
apply(행렬,2,함수) : 열 단위로 행렬에 함수 적용

예제)
행렬 생성
trial1=c(-0.85,1.31,0.98)
trial2=c(-1.14,1.34,-1.29)
trial3=c(-0.04,1.18,-0.24)
trial4=c(-0.60,1.44,-0.57)

A=cbind(trial1,trial2,trial3,trial4)
rownames(A)=c("Park","Lee","Kim")
A
> 세 명의 피실험자들을 대상으로 네번의 반복측정,
각 피실험자별 반복 측정된 값의 평균과 범위 계산

ex-1) 함수 apply()를 이용

apply(A,1,mean) #각 피실험자(행 벡터)에 대한 평균값
apply(A,1,range) #각 피실험자(행 벡터)에 대한 범위

ex-2) 행렬의 인덱싱 기법을 이용한 방법

평균값 계산

a=c(mean(A[1,]),mean(A[2,]),mean(A[3,]))
names(a)=c("Park","Lee","Kim")
a

범위 계산

b1=range(A[1,]);b2=range(A[2,]);b3=range(A[3,])
b=cbind(b1,b2,b3)
colnames(b)=c("Park","Lee","Kim")
b

ex-3) 함수 rowMeans()를 이용한 방법 (평균값만 계산 가능하다)

rowMeans(A) #apply(A,1,mean)와 동일

rowSums(A) #apply(A,1,sum)와 동일


3.3 데이터 프레임 다루기

대부분의 데이터 다듬기는 데이터 프레임을 대상으로 이루어짐
> read.table() 등으로 불러운 외부파일은 기본적으로 "데이터 프레임" 형태로 저장됨


3.3.1 데이터 프레임의 수정

통계분석을 진행하는 과정에서 데이터 프레임이 내용을 수정해야 하는 경우

1) 기존 변수 외에 다른 변수를 데이터 프레임에 추가해야 하는 경우
2) 기존 변수의 이름을 수정해야 하는 경우
3) 데이터 프레임을 특정 변수를 기준으로 다시 정렬해야 하는 경우

※주의! : 추가시킨 변수가 데이터 프레임의 일원이 되도록 해야 함

ex) 잘못 실행된 예

xyz=data.frame(x1=c(1,2,3,4),x2=c(5,6,7,8))
sum_x=x1+x2 #오류 : 객체를 발견할 수 없음 / 이유 : 새변수 sum_x는 xyz의 변수 중 일원이 아님, 인덱싱을 통하여 일원으로 만들어줘야함

sum_x=xyz$x1+xyz$x2 #오류 정정
ls() #함수 ls() : 영어 소문자 l, 작업공간에 임시 저장된 객체 리스트 확인

①새로운 숫자형 변수를 추가하는 방법

방법 1.

xyz=data.frame(x1=c(1,2,3,4),x2=c(5,6,7,8))
xyz$sum_x=xyz$x1+xyz$x2 #xyz의 변수 중 일원으로 sum_x추가, 일일히 인덱싱
head(xyz,n=2) #xyz 데이터 프레임의 앞 데이터 2줄 확인

방법 2.

xyz=data.frame(x1=c(1,2,3,4),x2=c(5,6,7,8))
attach(xyz) #앞으로 이용되는 변수에 전부 xyz 인덱싱
xyz$sum_x=x1+x2
detach(xyz)
head(xyz,n=2)

방법 3.

함수 transform() : transform(dataframe, new_variable = 수식)
new_variable : 신규 생성 변수의 이름 삽입

xyz=data.frame(x1=c(1,2,3,4),x2=c(5,6,7,8))
xyz=transform(xyz,sum_x=x1+x2) 
head(xyz,n=2)

함수 transform()을 이용하는 것이 가장 간단한 방법
여러개의 변수를 한꺼번에 추가하는 것도 가능하다

xyz=data.frame(x1=c(1,2,3,4),x2=c(5,6,7,8))
xyz=transform(xyz,sum_x=x1+x2,mean_x=(x1+x2)/2)
head(xyz,n=2)

head(xyz,n=2)
xyz$type[xyz$sum_x<10]="Small"
xyz$type[xyz$sum_x>=10]="Large"
xyz$type=factor(xyz$type,level=c("Small","Large")) #factor : 변수형 변수 함수

xyz

② 데이터 프레임의 변수 이름 수정

예제 : 데이터 프레임 xyz의 변수 x1을 age로, y1은 gender, z1은 income으로 수정

데이터 프레임 생성

x1=c(24,28,31,25)
y1=c("F","M","F","F")
z1=c(2000,3100,3800,2800)
xyz=data.frame(x1,y1,z1)
xyz

방법 1. 
함수 names()를 이용한 방법

names(xyz) #데이터 프레임 내 변수 확인
names(xyz)=c("age","gender","income") #각 순서대로 변수명 변경
names(xyz)

방법 2. 
패키지 reshape의 함수 rename()을 이용한 방법

head(xyz,n=2)

install.packages() #패키지 reshape 설치
library() #설치된 패키지 확인

library(reshape)

xyz=rename(xyz,c(x1="age",y1="gender",z1="income"))
head(xyz,n=2)


③ 데이터 프레임의 정렬

벡터의 정렬 : 함수 sort(),order()

x1
sort(x1) #오름차순으로 정렬
sort(x1,decreasing=TRUE) #decreasing=TRUE : 내림차순으로 정렬 옵션

x1
order(x1) #오름차순 정렬에서의 데이터 색인, 순서대로 번호 인덱싱 
x1[order(x1)] #오름차순
x1[order(-x1)] #내림차순

※데이터 프레임의 정렬 : 함수 order()
> 한 변수를 기준으로 하는 전체 데이터의 정렬

age=c(24,28,28,24)
gender=c("F","M","F","F")
income=c(2000,3100,3800,2800)
xyz=data.frame(age,gender,income)

xyz
attach(xyz)
xyz[order(age),] #age 변수만 정렬


여러 변수를 기준으로 하는 정렬

★ex) age 1차 오름차순 기준, gender 2차 오름차순 기준, income 3차 내림차순 기준

xyz
attach(xyz)
xyz[order(age,gender,-income),]
detach(xyz)


3.3.2 데이터의 취사선택

분석 과정에서 데이터의 일부분을 선택 혹은 삭제
데이터에 있는 결측값 제거
대규모 데이터에서 임의 표본 추출

☆★함수 subset()에 의한 데이터 선택

기본적인 데이터의 취사선택 방법 : 대괄호를 이용한 인덱싱 기법 []
>단점 : 선택조건이 복잡한 경우에는 번거롭다

ex) 패키지 MASS에 있는 데이터 프레임 Cars93

library(MASS) #설치되어있는 패키지 MASS 설치
names(Cars93) #Cars93 데이터 프레임의 변수 확인

예제 1-1) 변수 MPG.city가 30보다 큰 값을 갖는 Model은 무엇인가?

인덱싱 기법에 의한 데이터 선택

attach(Cars93)
Cars93[which(MPG.city>30),"Model"] #which(MPG.city>30) : MPG.city>30이 TRUE인 케이스의 인덱싱

예제 2-1) 변수 Cylinders가 4이고 Manufacturer가 Hyundai인 자동차의 Model과 Min.Price, Max.Price의 값을 출력하라

my_vars=c("Model","Min.Price","Max.Price")
my_cases=which(Cylinders==4&Manufacturer=="Hyundai")
Cars93[my_cases,my_vars]
detach(Cars93)

※별도의 함수 attach를 통한 데이터 지정이 필요없다

사용법 : subset(data,select,subset)
옵션 select : 선택 or 제거될 변수를 지정한다 / 다양한 변수 지정 시 select=c(x,y,z)형태로 사용
옵션 subset : 케이스를 선택하기 위한 조건 지정(범위 지정) / subset=()형태로 사용

예제 1-2)

subset(Cars93,Model,subset=(MPG.city>30))

예제 2-2)

subset(Cars93,select=c("Model","Min.Price","Max.Price"),subset=(Cylinders==4&Manufacturer=="Hyundai"))

※만일 선택하고자 하는 변수가 두번째 변수인 Molel에서 여덟번째 변수인 MPG.highway까지라고 한다면(연속된 변수)
함수 c()대신 콜론 연산자를 이용하여 인덱싱
select=Model:MPG.highway

※만일 27개의 변수 중 Price만을 제외하고자 할 경우
select=-Price
Model과 Price 두개를 제외하고자 할 경우
select=-c(Model,Price)
>제외는 마이너스(-)이다

② 데이터 프레임에서 결측값 제거

함수 na.omit()
데이터 프레임에서 결측값을 제거한다는 것 = 결측값이 있는 행 전체를 삭제한다는 의미
많은 정보의 손실이 있을 수 있음

head(airquality) #결측값 확인

air=na.omit(airquality)
head(air) #5,6행이 삭제되었음 확인

dim(airquality);dim(air) #dim() : 행렬, 데이터 프레임의 행과 열의 차원 확인

③ 대규모의 데이터에서 임의의 표본 추출

데이터 세트의 규모가 방대한 Data Mining이나 Machine Learning 분야에서는
데이터 세트의 일부분을 임의로 추출하여 다른 목적의 데이터 세트로 운영

단순임의추출방법 : 함수 sample()이용

sample(1:5,3) #디폴트=비복원 추출
sample(1:5,3,replace=TRUE) #옵션 replace=TRUE : 복원 추출

예제) 데이터 프레임 airquality의 153개 케이스 중 10개 케이스를 비복원으로 추출

my.index=sample(1:nrow(airquality),10) #행 번호만 추출됨, 해당 번호를 인덱싱 해야함
airquality[my.index,] #행에서만을 추출함을 지정해줘야 하기 때문에 뒤에 열은 모두 인덱싱(빈칸)


3.3.3 데이터 프레임의 결합

데이터가 따로 수집되어 몇개의 파일로 분산 정리된 경우에 사용

① 데이터의 수평적 결합(변수 확대) : 함수 cbind()
>각 데이터 프레임의 행 개수가 같고, 각 행이 동일한 대상에 관한 것

name=c("Park","Kim","Lee")
n.child=c(2,1,2)
data1=data.frame(name,n.child)
data1

birth.year=c(1980,1972,1975)
birth.place=c("Seoul","Osen","Swon")
data2=data.frame(birth.year,birth.place)
data2

cbind(data1,data2) #두 데이터 프레임의 수평적 결합

② 데이터의 수직적 결합(케이스 확대) : 함수 rbind()
>각 데이터 프레임의 열 개수가 같고, 각 열이 동일한 변수에 대한 것

name=c("Kwon","Shin")
n.child=c(2,0)
data3=data.frame(name,n.child)
data3

rbind(data1,data3)

★③기준 열에 의한 수평적 결합 : 함수 merge() / 가장 활용도가 높음
>각 데이터 프레임에 기준이 되는 열(key)가 있는 경우

name=c("Kim","Lee","Park","Kwon")
n.son=c(0,1,2,1)
data4=data.frame(name,n.son)
data4 #data1과 행의 개수도 다르고 행의 순서도 다르다

merge(data1,data4,by='name') #name을 기준으로 정렬, 겹치지 않는 행은 삭제

surname=c("Kim","Lee","Park","Kwon")
n.son=c(0,1,2,1)
data5=data.frame(surname,n.son)
data5

merge(data1,data5,by.x='name',by.y='surname') #서로 다른 변수명을 기준으로 결합

merge(data1,data5,by.x='name',by.y='surname',all=T) #옵션 all=T : 한쪽 데이터 프레임에 있는 케이스도 반영(결측값 생성)


☆★3.3.4 데이터 프레임의 함수 적용

① 그룹 데이터에 함수 적용

데이터 프레임에 '요인'이 있는 경우, 요인의 level에 따라 그룹을 형성할 수 있음
특정 변수의 각 그룹별 분포 비교

예제) 패키지 MASS에 있는 데이터 프레임 Cars93에는 Origin이라는 요인이 있음
수준(level)은 USA와 non-USA, 변수 MPG.city의 평균값을 Origin의 수준 별로 구해보자

1) 함수 split()을 이용한 방법 : 데이터를 분리

split(A,B) : A를 B에 따라 분리, 분리된 데이터는 '리스트'이다

library(MASS)
x=split(Cars93$MPG.city,Cars93$Origin)
x

mean(x[[1]]) #리스트 인덱싱 참조, 첫번째 데이터(USA)의 평균 / mean(x$USA)와 동일
mean(x[[2]]) #mean(x$non-USA)와 동일

★2) 함수 tapply()를 이용한 방법 : 훨씬 간편함

tapply()의 일반적인 사용법
tapply(data,factor,FUN) : factor의 각 수준별로 data를 분리하여 FUN(function)을 적용

with(Cars93,tapply(MPG.city,Origin,mean)) #with(데이터 프레임 이름, R명령문) > $ 기호 없이 변수를 사용할 수 있음

② 데이터 프레임의 모든 변수에 함수 적용

행렬의 경우 모든 열에 특정 함수 적용시키는 방법 : 함수 apply(matrix,2,FUN)
데이터 프레임도 2차원 배열, 따라서 행렬과 동일하게 함수 apply()를 사용할 수 있음

함수 apply()를 사용하기 위해서는 2차원 배열을 데이터가 모두 동일한 유형(mode)이 되어야 함
데이터 프레임 : 각 변수의 유형이 혼재되었으므로 함수 sapply()를 적용하는 것이 더 적합 'sapply'의 's'=subgroup

예제) 패키지 MASS에 있는 데이터프레임 cabbages의 변수들의 속성을 함수 class를 통하여 확인해보기

library(MASS)
head(cabbages)

sapply(cabbages,class) #apply(matrix,2,FUN) 함수 처럼 별도로 '열(2)'라고 지정하지 않음, sapply는 행,열 지정x
apply(cabbages,2,class) #잘못된 수행 결과


☆★3.3.5 데이터의 재구성

데이터의 재구성 : 패키지 reshape의 함수 melt(),cast()
>생략

데이터 집계 : 함수 aggregate()
>입력된 데이터가 지나치게 세분되어 있어 그룹별로 데이터를 집계해야 하는 경우

aggregate(data,by,FUN)
옵션 data : 데이터 집게가 되는 대상, 대부분 data frame
옵션 by : 리스트로 구성된 그룹 변수
옵션 FUN(function) : 데이터 집계에 사용될 변수

예제) 데이터 state.x77 
50개 주를 지역별로 묶어 각 지역에 속한 데이터의 평균 값이 우리가 필요한 데이터가 되는 경우
> 50개 주의 지역을 나타내는 변수는 state.region(외부 객체,factor)

head(state.x77,n=3)
head(state.region,n=3)

aggregate(state.x77,by=list(Region=state.region),FUN=mean)
>그룹 변수 state.region이 Region이라는 변수 명으로 결과에 추가됨,

2개 이상의 그룹 변수를 사용해야 하는 경우 by=list(var1,var2,...)


<연습 문제>

문제 1.
p.114에 주어진 데이터 생성

1)
seq(-5,5,0.2)

2)
x1=seq(1,9,2)
x1
x2=seq(2,10,2)
x2
x=c(x1,x2)
x

3)
x1=rep(1,1)
x2=rep(2,2)
x3=rep(3,3)
x4=rep(4,4)
x=c(x1,x2,x3,x4)
x

4)
rep(c(1,2,3),3)

5)
rep(c("a","b"),c(2,3))

6)
paste(rep("a",5),1:5,sep="")

문제 2.
x=c(10.4,5.6,3.1,6.4,21.7)
x

1)
mean(x)
sum(x)/length(x)

2)
sd(x)
sqrt(sum((x-mean(x))^2)/(length(x)-1))

3)
diff(x)
x[2:length(x)]-x[1:length(x)-1]

문제 3.
x=c(17,16,20,24,22,15,21,18)

1)
x[4]=c(23)
x

2)
sum(as.numeric(x>=20))

3)
mean(as.numeric(x<=18))

문제 4.
x1=c(-0.30,-0.60,-1.60,2.36,0.47)
x2=c(1.52,0.46,-1.10,1.18,-2.30)
x3=c(0.70,-0.87,-0.46,-0.24,-0.03)

1)
M1=rbind(x1,x2,x3)
rownames(M1)=paste("Location",1:3,sep="")
colnames(M1)=paste("Time",1:5,sep="")
M1

★2)
apply(M1,2,max) #열단위로 함수 적용

문제 5. 
score=c(85,91,75,69,52,95,88,100)
p.115 규칙확인

1)
grade=(score>=90)+(score>=80)+(score>=70)+(score>=60)+(score>=min(x))
factor(grade)
grade=factor(grade,labels=c("F","D","C","B","A"))
grade

2)
grade=cut(score,breaks=c(min(score),60,70,80,90,max(score)),include.lowest=TRUE,right=FALSE,labels=c("F","D","C","B","A"))
grade

3)
data.frame(score,grade)

문제 6.
Park=c(14,12,4)
Lee=c(21,16,8)
Kim=c(15,5,10)

sales=rbind(Park,Lee,Kim)
colnames(sales)=c("A","B","C")
sales

1)
apply(sales,1,sum)
apply(sales,1,mean)

2)
apply(sales,2,sum)
apply(sales,2,mean)

☆★문제 7. (회귀분석)
X=c(1,3,2,7,12,6,1,3,6,6,7)
Y=c(6.1,9.7,10.3,18.8,28.3,16.1,5.7,12.6,16.1,15.8,18.8)

1)
x1=cbind(1,X)
x1
beta.hat=solve(crossprod(x1,x1))%*%crossprod(x1,Y)
rownames(beta.hat)=c("beta_0","beta_1")
colnames(beta.hat)=c("Estimate")
beta.hat

문제 8.

1)
soju=data.frame(c(23.8,23.7,24.7,25.6,23.5,24.7,25.3,26.3,25.7,24.7,23.3,24.3,24.5,
24.8,24.2,24.7,25.1,26.4,28.2,25.4))
names(soju)=c("soju")
soju

2)
soju=transform(soju,year=1981:2000)
head(soju)
tail(soju)

3)
attach(soju)
period=(year>=min(soju))+(year>=1980)+(year>=1990)
soju=transform(soju,period=factor(period,labels=c("80's","90's")))
head(soju,n=3)
tail(soju,n=3)

4)☆★
with(soju,tapply(soju,period,mean))

문제 9.

1)
air=na.omit(airquality)

2)☆★
attach(air)
air_var1=c("Ozone","Solar.R")
air_cases1=which((Wind>=mean(Wind))&(Temp<mean(Temp)))
air_sub1=air[air_cases1,air_var1]
air_sub1
detach(air)

또는

air_sub1=subset(air,select=c("Ozone","Solar.R"),
subset=((Wind>=mean(Wind))&(Temp<mean(Temp))))
air_sub1

3)
attach(air)
air_var2=c("Ozone","Solar.R")
air_cases2=which((Wind<mean(Wind))&(Temp>=mean(Temp)))
air_sub2=air[air_cases2,air_var2]
air_sub2
detach(air)

또는

air_sub2=subset(air,select=c("Ozone","Solar.R"),
subset=((Wind<mean(Wind))&(Temp>=mean(Temp))))
air_sub2

4)
list(apply(air_sub1,2,mean),apply(air_sub2,2,mean))


<4장 : R에서 그래프 그리기>

통계분석과 그래프 
> 그래프는 데이터 분석 과정에서 필수적 요소
대규모 데이터가 갖고 있는 정보를 정교하게 표시할 수 있는 그래프의 중요성이 나날이 부각되고 있음


4.1 예제 작업

R에서의 그래프 작성 방식 : 우선 주요한 그래프를 작성하고 이어서, 선, 기호 문자 등을 그래프에 덧붙이는 형식
> 그래프의 완성도를 차근차근 높일 수 있는 진일보한 방식

R그래프 함수

높은 수준의 그래프 함수 - 하나의 완성된 그래프 생성, 주요한 그래프 작성
ex) plot()

낮은 수준의 그래프 함수 - 기존에 존재한 그래프에 선, 기호, 문자 등을 추가
ex) points(), lines(), test()

예제)
attach(cars)
plot(dist~speed)
abline(lm(dist~speed),col=4)
title("Speed and Stopping Distance of Cars")
detach(cars)

작성된 그래프의 임시 저장

높은 수준의 그래프 : 기존의 그래프는 없어지고 새로운 그래프만 Graphics 창에 남게됨

기존 그래프의 임시 저장
graph 클릭 - 메뉴 - 작업기록 - 기록 후 생성된 그래프 선택

그래픽 창 생성 : 함수 win.graph() : 기존 그래픽 창을 그대로 둔 채 새로운 그래픽 창 생성

x=(0:20)*pi/10
y=cos(x)
plot(x,y)
win.graph()
ysin=sin(x)
plot(x,ysin)


4.2 그래픽 모수

그래프의 다양한 특징을 조절하는 옵션
현재 R에서 사용하고 있는 그래픽 모수 : 71개

그래픽 모수 수정 방법 :
1. 함수 par()이용
2. 각 그래프 함수 안에서 옵션 이용

예제)
plot(dist~speed,cars)

>함수 par()에 의한 그래픽 모수 수정 예시
opar=par(no.readonly=TRUE) #그래픽 모수의 원래 값 저장
par(pch=19) #점 모양 변경
plot(dist~speed,cars) # 1)그래프 >4단원 p.2
par(lty=3) #선 모양 변경
plot(dist~speed,type='b',cars) 2)그래프 >4단원 p.2
par(opar) #그래픽 모수의 원래 값으로 복귀
win.graph()
plot(dist~speed,cars) #비교해보기

각 그래프의 함수 옵션 이용

plot(dist~speed,type='b',lty=3,pch=19,cars)

>함수 par()을 이용해야 만이 수정할 수 있는 모수가 있음


☆4.2.1 기호 및 선과 관련된 그래픽 모수 (옵션)

pch : 기호의 종류, 0~25 중 하나의 숫자를 선택하거나 인용부호 안에 하나의 문자를 지정할 수 있다.(Point Character)
ex) pch=2, pch"*", ...
lty : 선의 종류, 1~6 중 하나의 숫자를 선택 (Line Type)
cex : 기호의 크기, 디폴트 : cex=1, cex=2는 2배 확장된 크기로 표시 (Character EXpansion ratio)
lwd : 선의 굵기, 디폴트 : lwd=1, lwd=2는 2배 확장된 굵기로 표시 (Line WiDth)

옵션 pch, lty의 선택 가능한 형태
>p.12 확인

plot(dist~speed,type='b',lty=,pch=,cars) #다양한 형태 확인


☆4.2.2 색깔과 관련된 함수

col : 그래프에 그려지는 기호, 선, 문자 등의 색깔을 지정 (COLlor)
col.lab : XY축 라벨의 색깔 (LABel)
col.main : 그래프 주 제목의 색깔 (MAIN title)
col.sub : 그래프 부 제목의 색깔 (SUBtitle)

모수에 색깔 지정하는 법 

1) 숫자 이용 
ex) col=2

0 : 흰색 
1 : 검은색
2 : 빨간색
3 : 녹색
4 : 파란색
5 : 청록색
6 : 자주색
7 : 노란색
8 : 회색
9 이상의 숫자는 검은색부터 순환된다

pie(rep(1,16),col=1:16)

2) 문자 이용

함수 colors()를 실행시키면 657개의 색을 나타내는 문자 벡터가 알파벳 순으로 정렬된

colors()[1:10]

단점 : 너무 많은 색이 정의되어 있어 선택이 어렵다

예제)

1. colors()의 결과러 생성된 벡터의 색인 지정하는 방법

pie(rep(1,3)) #첫번째 영역의 크기 1, 두번째 1, 세번째 1
pie(rep(1,3),col=colors()[c(552,254,26)])

2. colors()에서 지정된 문자를 이용하는 방법

pie(rep(1,3),col=c("red","green","blue"))

번호에 지정된 문자 확인
colors()[552] 
colors()[254]
colors()[26]

색깔과 관련된 유용한 함수

gray() : 검은색에서 흰색까지 명도 단계별로 색 표현
ex) gray(0) : 검은색 gray(1) : 흰색

특정 테마에 따른 인접한 색 표현
rainbow(), heat.colors(),terrain.colors(),topo.colors(),cm.colors()

n=10
pie(rep(1,n),col=gray(1:n/n),labels=paste("gray(",1:n/n,")",sep=""))

pie(rep(1,n),col=heat.colors(n))

pie(rep(1,n),col=terrain.colors(n))

pie(rep(1,n),col=topo.colors(n))

pie(rep(1,n),col=cm.colors(n))


4.2.3 그래프 영역과 관련된 모수

Graphics 창의 영역

그래프 영역 : 그래프가 그려지는 영역
내부마진 영역 : X축과 Y축의 라벨, 그래프 제목 등을 위해서 미리 확보된 영역
외부마진 영역 : 여러개의 그래프를 함께 그릴 떄, 그래프 전체에 대한 제목 등을 위한 영역, 사용자가 직접 확보해야함
>4단원 p.4 sample 확인

내부 및 외부마진 영역 조절 모수

mar : 내부마진 영역 조절, 디폴트 값 c(5.1,4.1,4.1,2.1)
oma : 외부마진 영역 조절, 디폴트 값 c(0,0,0,0)

모수 mar의 디폴트 값인 c(5.1,4.1,4.1,2.1)의 의미
cex=1의 크기로 밑면은 5.1줄
왼쪽면과 윗면은 4.1줄
오른쪽 면은 2.1줄로 공간 확보

> 모수 mar와 oma의 수정은 함수 par()을 이용


4.3 낮은 수준의 그래프 함수


4.3.1 그래프의 제목 및 XY축 라벨 추가

높은 수준의 그래프 함수 중 그래프의 제목 및 XY축 라벨을 추가할 수 있는 경우
ex) plot(), hist(), boxplot(), ...

제목 등을 덧붙이는 기능이 없는 함수의 경우

>함수 title()을 이용
기본 사용법 : title(main="그래프의 주제목",sub="그래프의 부제목",xlab="X축의 라벨",ylab="Y축의 라벨")

ex)
함수 plot()은 그래프 제목 및 XY축 라벨을 붙이는 기능이 있는 함수이지만 title()함수 이용하여 붙여보기
함수 plot()의 디폴트 : 변수 이름, 디폴트 제한 위해서는 옵션 ann=FALSE를 포함시켜야 함 ※(ann=annotation)

plot(dist~speed,cars,ann=FALSE)
title(main="산점도",col.main="red",cex.main=2,
	sub="데이터 프레임 cars",col.sub="blue",
	cex.sub=1.2,xlab="차의 속도",
	ylab="멈추는데 필요한 거리",
	col.lab="magenta",cex.lab=0.8)

>함수 plot()의 경우 그래프 제목 및 XY축 라벨을 추가하는 자연스러운 방법

plot(dist~speed,cars,
	main="산점도",col.main="red",cex.main=2,
	sub="데이터 프레임 cars",col.sub="blue",cex.sub=1.2,
	xlab="차의 속도", ylab="멈추는데 필요한 거리",
	col.lab="magenta",cex.lab=0.8)


4.3.2 XY축 형태 변경

기본적으로 제공되는 XY축 형태

박스형 프레임 : 그래프의 영역과 내부마진 영역 경계
X축 : 밑면
Y축 : 왼쪽 면
각 측의 범위 : (최소,최대)+오차
눈금 : 그래프 바깥쪽
눈금라벨 : 축의 진행방향과 동일 (수평방향)

기본적으로 제공되는 XY축 형태의 수정

함수 axis() 이용
axis(size,at=,labels=,pos=,lty=,col=,las=,tck=,...)

size : 그래프 영역의 각 변을 지칭하는 정수 (1=밑변, 2=왼쪽 변, 3=윗변, 4=오른쪽 변)
at : 축의 눈금을 표시할 곳을 지칭하는 숫자형 벡터
labels : 각 눈금의 라벨을 지정하는 문자형 벡터
pos : 해당 축이 다른 축과 교차되는 좌표
lty : 축을 그리는 선의 유형
col : 축을 그리는 선과 눈금의 색깔
las : 눈금 라벨의 방향 (0=축과 수평(디폴트), 2=축과 수직) (LAbel Side)
tck : 눈금길이 지정, 양수 : 그래프 안쪽, 음수 : 그래프 바깥쪽으로 눈금 작성 (0=눈금 제거, 1: 격자선, 디폴트=-0.01)

예제)
기본 XY축 제거
plot(dist~speed,cars,ann=FALSE) 

plot(dist~speed,cars,axes=FALSE,ann=FALSE)
plot(dist~speed,cars,axes=FALSE,xlab="",ylab="")

축 눈금 제거
plot(dist~speed,cars,xaxt="n")
plot(dist~speed,cars,yaxt="n")

plot(dist~speed,cars,xaxt="n",yaxt="n")

예제)
XY축 형태 수정

>수정 사항
1. 박스형 프레임 제거
2. X축 : 밑면에 0부터 30까지 5간격으로 눈금 작성, 눈금은 그래프 안쪽, 눈금 라벨은 축과 수평
3. Y축 : 왼쪽 면에 0부터 130까지 10간격으로 눈금 작성, 눈금은 그래프 바깥쪽, 눈금 라벨은 축과 수직

시도 1)
x=seq(0,30,5);y=seq(0,130,10)
plot(dist~speed,cars,axes=FALSE) #1.
axis(side=1,at=x,labels=x,las=0,tck=0.1)
axis(side=2,at=y,labels=y,las=2,tck=-0.1)

>X축과 Y축이 의도한 것보다 짧음 / 두 축이 교차하지 않음

시도 2)
plot(dist~speed,cars,axes=FALSE,xlim=c(0,30),ylim=c(0,130),
   xlab="Speed",ylab="Disatance",main="Speed and Stopping Distance of Cars")
axis(side=1,at=x,pos=0,las=0,tck=.01)
axis(side=2,at=y,pos=0,las=2,tck=-.01)

※
xlim, ylim : 각각 XY축의 범위 설정
pos= : 좌표를 기준으로 문자를 입력할 상대적인 위치(교차되는 좌표)
>따라서 위 예시는 (0.0)에서 xy축이 교차한다

☆★연습문제
>4단윈 p.6 ppt(36)

y=c(5,10,30,50,100)
plot(log10(dist)~speed,cars,ylab="dist",ylim=dist.original)
axis(side=2,at=y,labels=y)
dist.original=c(5,10,30,50,100)

win.graph()
plot(dist~speed,cars,ylab="dist",)


4.3.3 직선 및 점 추가

기존의 그래프에 직선 및 점을 추가하는 낮은 수준의 그래프 함수
lines() : 주어진 좌표를 순서대로 선으로 연결
points() : 주어진 좌표에 점(기호)추가
abline() : 직선 추가

1) 함수 lines()
주어진 좌표를 순서대로 선으로 연결하는 기능

기본적인 사용법 : lines(x,y=NULL,type='l",...)

1. y 벡터가 있는 경우 : i번째 요소 (x[i],y[i])와 i+1번째 요소인 (x[i+1],y[i+1])을 선으로 연결
2. y 벡터가 없는 경우 : (i,x[i])와 (i+1,x[i+1])을 선으로 연결
3. type은 함수 plot()과 points()에서도 사용되는 요소로 그래프의 유형 결정

☆★옵션 type

type="p" : 점(point) 그래프, 함수 plot(), point()의 디폴트 type 값
type="l" : 선(line) 그래프, 함수 line()의 디폴트 type 값
type="b" : 점과 선(both) 그래프
type="o" : 점과 선이 겹쳐지는(overlapped) 그래프
type="s" : 계단식(step) 그래프
type="n" : 그래프 없음(no plotting)

attach(cars)
plot(dist~speed,cars)
lines(speed,dist,type="o")

2) 함수 points()
주어진 좌표에 점을 추가하는 기능

기본적인 사용법 : point(x,y=NULL,type="p",....)
>함수 lines()와 사용법은 거의 동일

3) 함수 abline()
그래프에 직선을 추가하는 기능

abline(a,b) : 절편이 a, 기울기가 b인 직선
abline(coef=c(a,b)) : coef는 절편과 기울기로 이루어진 벡터
abline(h=) : 수평선, h에는 수평선이 지나가는 y값
abline(v=) : 수직선, v에는 수직선이 지나가는 x값
abline(reg=) : 회귀직선, reg는 함수 lm() 등으로 생성되는 regression 객체

예제 1)
cars의 두 변수 dist의 speed의 산점도에 회귀직선과 두 변수의 평균값을 지나는 수평선과 수직선 추가

attach(cars)
plot(dist~speed)
abline(lm(dist~speed))
abline(v=mean(speed),col="red")
abline(h=mean(dist),col="blue")

추정된 회귀직선은 반드시 좌표 (mean(x),mean(y))를 통과한다는 통계적 정리를 그래프로 확인할 수 있다

예제 2)
cars의 두 변수 dist와 speed의 산점도에 비모수회귀곡선 추가

※비모수 회귀 : 회귀함수 형태에 대한 특별한 가정 사항 없이 주어진 데이터를 가장 잘 설명할 수 있는 회귀곡선을 찾는 방법
선형회귀 모형이 적절하지 않은 상황에서의 회귀함수 추정 or 탐색적 데이터 분석 단계에서 가장 적절한 선형회귀모형을 제시하는 도구

관련함수 : loess(), loess.smooth(), scatter.smooth(),...

plot(dist~speed,cars)
fit=loess.smooth(speed,dist)
lines(fit$x,fit$y,col="red")
abline(lm(dist~speed))

객체 fit : 함수 loess.smooth()의 결과가 할당된 리스트의 객체
fit$x : 비모수 회귀곡선이 추정된 X변수의 값
fit$y : 추정된 비모수 회귀곡선의 값
> 교재 118~120쪽

예제 3)
패키지 MASS의 Rubber

타이어 고무에 대한 실험 데이터 : 고무의 강도(hard)와 인장 강도(tens)에 따른 고무의 손실 양(loss)
tens와 loss의 산점도를
hard>=62인 경우 속이 찬 원
hard<62인 경우 속이 찬 파란 네모

library(MASS)
attach(Rubber)
plot(tens,loss,type="n")
points(tens[hard>=62],loss[hard>=62],col="red",pch=19)
points(tens[hard<62],loss[hard<62],col="blue",pch=15)


4.3.4 범례 추가

하나의 그래프에 몇 개의 그룹 데이터가 다른 선 또는 기호 등으로 구분되어 그려져 있는 경우
> 각 기호가 어떤 그룹을 나타내는지 표시해야 함(범례)

함수 legend() : legend(위치 지정, 범례의 내용,...)

1) 위치 지정 : 범례의 위치를 지정하는 방법

1. 범례가 들어가는 사각형의 왼쪽 위 꼭짓점의 (x,y)좌표 제공
2. "locator(1)"을 입력, 이 경우 마우스로 위치를 결정
3. 다음의 키워드 중 하나를 선택 : bottomleft, bottom, bottomright, left, center, right, topleft, top, topright

2) 범례 내용 : 범례에 사용될 라벨로 구성된 문자형 벡터

3) 다른 옵션 : col, pch, lwd, lty, fill, bty="n"

예제)
4.3.3 예제 3에 범례 추가
legend("topright",c("hard>=62","hard<62"),col=c("red","blue"),pch=c(19,15))

legend(210,360,c("hard>=62","hard<62"),col=c("red","blue"),pch=c(19,15)) #210,360 : 좌표설정


4.3.5 문자 추가

그래프 영역에 문자 추가 : 함수 text()

text(x,y,lables=,pos=,...)

x,y : 문자가 추가되는 지점의 좌표
labels : 추가되는 문자를 지정하는 문자형 벡터
pos : 문자의 위치를 조정하는 상수, 지정된 지점의 아래쪽(1), 왼쪽(2), 위쪽(3), 오른쪽(4)

>그래프에 표시된 점에 라벨을 붙일 때 유용하다

예제)
state.x77 : 미국 50개 주의 인구, 소득, 문맹률 등을 나타내는 행렬

두번쨰 열인 'Income'과 여섯 번째 열인 'HS Grad'의 산점도 작성
>각 점에 주 이름을 라벨로 추가, 주 이름은 rownames(state.x77)에 있음

colnames(state.x77)
rownames(state.x77)

x=state.x77[,2]
y=state.x77[,6]
plot(x,y,pch=19,cex=0.5,xlab="Income",ylab="HS Grad")
text(x,y,labels=rownames(state.x77),col="red")

>라벨이 서로 겹쳐 있음 : 점 사이에 공간이 충분치 않음, 라벨(주 이름)이 너무 길다

영어 문자열 축소 함수 abbreviate() 사용

abbreviate(rownames(state.x77),minlength=2)[1:5] #데이터 확인

x=state.x77[,2]
y=state.x77[,6]
plot(x,y,pch=19,cex=0.5,xlab="Income",ylab="HS Grad")
text(x,y,labels=abbreviate(rownames(state.x77),minlength=2),cex=0.8,pos=3,col="red")

내부마진 및 외부마진에 문자 추가 : 함수 mtext()

mtext("추가되는 문자", side=, line=, adj=, outer=,...)

side : 문자가 추가되는 마진의 면, 밑면(1), 왼쪽 면(2), 윗면(3, 디폴트), 오른쪽 면(4)
line : 추가되는 문자와 그래프 영역 사이의 거리, ex) line=1은 cex=1 크기의 문자가 한줄 들어갈 수 있는 간격, 디폴트 line=0
adj : 문자의 정렬 방향 (adjust), adj=0 왼쪽(아래쪽), adj=1 오른쪽(위쪽), 디폴트는 중앙
outer : TRUE(외부마진), FALSE(내부마진,디폴트)

x=state.x77[,2]
y=state.x77[,6]
plot(x,y,pch=19,cex=0.5,xlab="Income",ylab="HS Grad")
text(x,y,labels=abbreviate(rownames(state.x77),minlength=2),cex=0.8,pos=3,col="red")
mtext("US State Facts",side=3,line=1,cex=2,adj=1)


4.4 그래프의 결합

여러개의 독립된 그래프를 하나의 그래프 창에서 나타내야 하는 경우
높은 수준의 그래프 함수를 실행하기 전에 미리 그래프 영역을 분할시켜야 함

그래프 영역의 분할 : 함수 par(),함수 layout()

1) 함수 par()에 의한 분할 : 동일한 크기의 영역
par(mfrow=c(nrows,ncols))
par(mfcol=c(nrows,ncols))

par(mfrow=c(3,2)) #가로부터 놓기
par(mfcol=c(3,2)) #세로부터 놓기

my_par=par(no.readonly=TRUE) #1,1개 넣을 수 있도록 저장
par(oma=c(0,0,5,0)) #제목을 위해 외부마진 공간 확보
attach(cars)
par(mfrow=c(1,2))
hist(dist,col="skyblue")
hist(speed,col="purple")
mtext("Histogram of two variables",outer=TRUE,cex=2)
par(my_par)

2) 함수 layout()에 의한 분할 : 영역 크기 및 순서 조절

layout(matrix(1:4,ncol=2,byrow=TRUE)) #행이 먼저오도록 그래프 배치
layout(matrix(1:4,ncol=2))

layout(matrix(1:2),heights=c(2,1)) #1이 전체 공간의 2/3 차지
layout(matrix(c(1,2,3,2),ncol=2),heights=c(2,1)) #2가 밑으로감, 1,3이 전체 공간의 2/3 차지

layout(matrix(c(1,2,0,3),ncol=2),height=c(1,2),width=c(2,1)) #4단원 p.11 ppt(63)참고

my_par=par(no.readonly=TRUE)
par(oma=c(0,0,5,0))
attach(cars)
layout(matrix(c(1,2,0,3),ncol=2),height=c(1,2),width=c(2.5,1))
boxplot(dist,horizontal=TRUE) #수평배치
plot(dist~speed)
boxplot(speed)
mtext("Enhanced Scatterplot",line=1,cex=2,outer=TRUE)
layout(matrix(1))
par(my_par)
detach(cars)


※4.3.보충 그래프 패키지

기본 패키지 : grDevice, graphics
활용 패키지 : grid, lattice

x=(0:20)*pi/10
ysin=sin(x)
library(lattice)
xyplot(ysin~x)


<연습문제>

문제 1.
pch 옵션 이용하여 기호(점) 유형 찾아보기

문제 2.
lty 옵션 이용하여 선의 유형 찾아보기

문제 3.

1)
air=na.omit(airquality)

2)
attach(air)
plot(Solar.R,Ozone,type="n")
points(Solar.R[Wind>=mean(Wind)&Temp<mean(Temp)],Ozone[Wind>=mean(Wind)&Temp<mean(Temp)],pch=19)
points(Solar.R[Wind<mean(Wind)&Temp>=mean(Temp)],Ozone[Wind<mean(Wind)&Temp>=mean(Temp)],pch=3)

3)
legend(25,170,c("High wind and low temp","Low wind and high temp)"),pch=c(19,3))


<5장 : R에서 프로그래밍 하기>

R 언어의 가장 기본적인 개념

① 표현식(Expression)
R 프로그램은 일련의 표현식으로 이루어짐
ex) 데이터 할당 문장, 조건을 비교하는 문장, 산술식 등등
새로운 줄 또는 세미콜론으로 분리한다

② 객체(Object)
R 프로그램의 기본 요소
R에서 다루는 모든 것이 객체; 데이터 객체, 함수, 표현식

③ 함수(Function)
인수(변수)라는 객체를 입력시키면 결과물 객체를 생성시키는 또 다른 R의 객체
R에서 수행되는 거의 모든 작업이 함수로 진행


5.1 프로세스의 흐름

기본적인 R의 수행방식 : 첫 줄에서 시작하여 한 줄씩 내려가며 모든 표현식을 수행하는 방식
>이러한 수행 방식으로는 해결하기 어려운 경우가 있음
ex) 어떤 조건의 만족 여부에 따라 실행되느 표현식 / 몇 번을 반족해서 실행시켜야 하는 표현식

프로세스의 흐름을 조절하는 방법
>루프(loof)연산
>조건 연산


☆★5.1.1 루프 연산

프로그램의 특정 부분을 일정 횟수 "반복" 하는 작업

① 함수 for()

for(var in seq){표현식}

for(i in 1:5)print(1)

옵션 var : 변수 이름
옵션 seq : 벡터

변수 var은 seq의 값을 차례로 취하면서 표현식을 실행

② 함수 while()

while(조건){표현식}

i=1
while(i<=5){
  print(i)
  i=i+1
}

예제)Factorial 계산

1)함수 for에 의한 계산

fac.x=1
for(i in 1:5){
       fac.x=fac.x*i
       cat(i,"!=",fac.x,"\n",sep="") #"\n" = 줄바꿈
}

2)함수 while에 의한 계산

fac.x=1
i=1
while(i<=5){
       fac.x=fac.x*i
       cat(i,"!=",fac.x,"\n",sep="")
       i=i+1
}

연습문제)

1)1에서 5까지 각각 한 개 솟자씩 더한 결과를 보여주는 프로그램
	

1-1)
sum.x=1:5
for(i in 1){
       sum.x=sum(sum.x)
       cat("sum(1:5)=",sum.x,"\n",sep="")
}

1-1)
sum.x=1:5
i=1
while(i<=1){
      sum.x=sum(sum.x)
       cat("sum(1:5)=",sum.x,"\n",sep="")
      i=i+1
}

☆ 2)함수 while()을 이용하여 5개의 자료 1,1,1,8,7,6의 평균을 계산하는 프로그램 (문제 이상)

while(


5.1.2 조건 연산

주어진 조건의 만족 여부에 따라 실행되는 표현식을 다르게 하는 연산

① 함수 if의 활용법

1)
if(조건){		조건이 만족되면 표현식 실행
	표현식
)

2)
if(조건){		조건이 만족되면 표현식1 실행
	표현식1
}else{		조건이 만족되지 않으면 표현식2 실행
	표현식2
}

3)
if(조건){		조건1이 만족되면 표현식1 실행
	표현식1
}else if{		조건2가 만족되면 표현식2 실행
	표현식2
}else{		그 외의 경우에는 표현식3 실행
}

※유의사항
if(조건){
	표현식1} <- if() 조건문이 종료된 것으로 간주한다
else{
	표현식2		   else로 시작하는 명령문이 없어 오류가 발생한다
}

예제)

x=runif(1)-0.5;x #runif(n) : n개의 난수발생

if(x<0)print(abs(x)) #abs() : 절댓값

if(x<0)print(abs(x))else print(x)

ifelse(x<0,abs(x),x) #ifelse(조건) : 추후설명

if(x<0){print("x is negative")}else {print("x is positive")} #복합실행

if(x>=-0.5&&x<=0.5)print(x)else{print("wrong number")} #복합조건

☆★※복합 조건=
&,| : vector의 element 별로 조건 체크
&&,|| : vector의 첫번째 값만 체크

x=c(1,2,5,7,8)
y=c(3,7,5,2,1)
w=2;u=7

(x>2)&(y>3) #각 요소가 만족하는가?
(x>2)&&(y>3) #1,3이 만족하는가?
(w>2)&(u>3)
(w>2)&&(u>3)

(x>2)|(y>3) # | : or
(x>2)||(y>3)
(w>2)|(u>3)
(w>2)||(u>3)

예제) 근의 공식을 이용하여 이차 방정식의 근을 구하는 프로그램 작성

ax^2+bx+c=0의 근 구하기

판별식 D=b^2-4ac

D>0 (-b+sqrt(D))/(2*a),(-b-sqrt(D))/(2*a)
D=0 (-b)/(2*a)
D<0 No roots

x^2+4x+3=0의 근 구해보기

근을 roots라고 했을 때

a=1;b=4;c=3
D=b^2-4*a*c

if(D>0){
	roots=c((-b+sqrt(D))/(2*a),(-b-sqrt(D))/(2*a))
}else if(D==0){
	roots=c(-b/(2*a))
}else{
	roots=c("No root")
}
print(roots)

☆★※함수 if() 사용 시 유의할 점

if() 조건에는 하나의 논리값만 사용됨

예) 두 벡터 x와 y의 구성요소를 비교하여 값이 큰 요소를 출력한다

x=c(10,3,6,9)
y=c(1,5,4,12)

if(x>y) x else y
> x>y에는 TFTF라는 네개의 논리값이 존재한다


2) 함수 ifelse()

사용하고자 하는 조건이 하나의 논리값이 아닌 논리벡터의 경우

ifelse(조건, 표현식1, 표현식2)

조건이 만족되는 표현식1, 만족되지 않으면 표현식2를 실행

x=c(10,3,6,9)
y=c(1,5,4,12)

ifelse(x>y,x,y)

예) 주어진 점수가 50미만이면 'Fall", 50이상이면 'Pass'를 점수와 함께 출력하는 프로그램 작성

score=c(80,75,40,98)

grade=ifelse(score>=50,"Pass","Fall")
data.frame(score,grade)

연습문제) If문

1)1에서 10까지 정수를 더할 때 홀수는 원래 값을 더하고 짝수는 원래 값의 2배를 더한 결과를 출력하라

n=1:10
sum.n=0
i=1:10

ifelse(n==2*n,sum.n=sum.n+2*n[i],sum.n=sum.n+n[i])


2)함수 while()과 if()를 사용하여 피보나치 수열의 제 1항부터 제12항까지 출력한느 프로그램을 작성해라.

☆★
2-1-1)
x=c(0,1)
while(length(x)<12){
	position=length(x)
	new=x[position]+x[position-1]
	x=c(x,new)
}
print(x)

2-1-1)(함수화)
Fibonacci=function(n){
	x=c(0,1)
	while(length(x)<n){
		position=length(x)
		new=x[position]+x[position-1]
		x=c(x,new)
	}
	return(x)
}
Fibonacci(12)


5.2 사용자정의 함수

R의 큰 장점 중 하나 : 사용자가 직접 함수를 정의하여 사용할 수 있음
> 전체적으로 프로그램이 상당히 간결해짐
> 분석 절차가 훨씬 더 효율적이게 된다

패키지
> 사용자정의 함수의 묶음


5.2.1 함수의 정의

my_func=function(arg1,arg2,...){
	표현식
	return(객체)
}

my_func : 함수이름
arg1,arg2,... : 변수 이름

표현식의 수행결과가 할당된 객체는 함수 return(객체)로 출력된다.


☆★5.2.2 변수

①변수에 디폴트 값 부여

f1=function(x,y)x+y #변수 x,y에 디폴트 값 무존재
f1(2,3)

f2=function(x,y=5)x+y #변수 y에 디폴트 값 5 입력
f2(2)

f2(2,3) #변수 y에 값을 입력 시 디폴트 값을 무시함

②생략부호 변수

my_plot1=function(x,y,...){ #... : 생략부호
	plot(x,y,...)
}

my_plot2=function(x,y){
	plot(x,y)
}

>함수 my_plot()은 함수 plot()의 여러 옵션을 부가적으로 이용할 수 있다(plot()함수가 표현식이기 때문)

attach(cars)
my_plot1(speed,dist)
my_plot1(speed,dist,col="red",pch=19)
my_plot2(speed,dist)
my_plot2(speed,dist,col="red",pch=19) #옵션이 정의되지 않아 사용 불가
detach(cars)


5.2.3 변수의 지정

함수의 변수를 지정하는 법

예시)
my_power=function(first,second)first^second

① 전체 이름 : 함수를 정의할 때 사용된 변수의 이름 전체를 사용하여 지정하는 방법

my_power(second=5,first=2)

② 부분 이름 : 함수를 정의할 때 사용된 변수의 처음 일부분만을 사용하여 지정하는 방법

my_power(s=5,f=2)

③ 변수의 순서 : 함수를 정의할 때 지정된 변수의 순서

my_power(2,5)


☆★5.3.2 결과의 출력

함수 return()에 의한 출력
함수 return()이 없는 경우 : 마지막 표현식의 실행 결과

예제) 함수 my_desc()에 입력된 벡터의 평균과 표준편차를 계산하여 리스트 형태로 출력

my_desc=function(x){
		m.x=mean(x);sd.x=sd(x)
		res=list(mean=m.x,sd=sd.x)
		return(res)
}

① 함수 return()에 의한 실행 결과 출력

with(cars,my_desc(x=dist))

② 함수 return()이 없는 함수의 결과 출력
>마지막 표현식이 할당문일 경우 아무런 결과도 출력되지 않음

my_desc=function(x){
		m.x=mean(x);sd.x=sd(x)
		list(mean=m.x,sd=sd.x)
}

with(cars,my_desc(x=dist)) 
>만일 my_desc에 출력할 리스트를 res=list(mean=m.x,sd=sd.x)와 같이 할당하였을 경우에는 출력되지 않음
출력을 위해서는 표현식 res를 할당해서는 안됨


☆★실습예제 1. 이차방정식 근을 구하는 함수

함수를 이용해서 작성하는 이유
>메인 프로그램으리 간결하게 하기 위함

작성된 함수를 이용하는 방법
>이차방정식의 근을 구하는 표현식을 다른 스크립트 파일에 사용자정의 함수로 이용
>함수 sourc()로 사용자정의 함수가 있는 스크립트 파일을 실행
>작성된 사용자정의 함수를 사용

① 사용자정의 함수 작성 및 실행 절차 1
: 다음 프로그램을 스크립트 파일에 입력하여 작업 디렉토리 혹은 다른 폴더에 prog1.R이라는 이름으로 저장하기

find_roots=function(a,b,c){
	if(a==0){
		roots=c("이차방정식이 아님")
	}else{
		D=b^2-4*a*c
		if(D>0){
			roots=c((-b+sqrt(D))/(2*a),(-b-sqrt(D))/(2*a))
		}else if(D==0){
			roots=-b/(2*a)
		}else{
			roots=("No root")
		}
	}
	return(roots)
}

② 사용자정의 함수 작성 및 실행 절차 2

함수 source()의 실행

1. 디폴트 작업 디렉토리에 prog1.R을 저장한 경우
source("prog1.R")

※
getwd() : 현재의 작업 디렉토리(경로)를 확인
setwd() : 경로 디폴트 지정

2. 다른 폴더에 prog1.R을 저장한 경우
source("D:/민아/성민아/과제충 성민아/전산실습/prog1.R")

③ 사용자정의 함수 작성 및 실행 절차 3

함수 find_roots()를 사용하여 이차방정식의 근을 구한다

find_roots(a=1,b=-4,c=3)

find_roots(a=2,b=3,c=5)


☆★실습예제 2. 요약 통계량 계산

>요약 통계량의 종류 선택
: 평균과 표준편차 / 중앙값과 MAD(mean absolute deviation) 

MAD=median(｜Xi-median(Xi)｜)

>계산된 요약 통계량의 값 Console 창에 출력 여부 선택

① 절차 1

다음의 프로그램을 Prog2.R이란 이름의 스크립트 파일에 입력

my_desc=function(x,parametric=TRUE,print=FALSE){ #parametric은 그냥 변수이름(옵션명), TRUE, FALSE는 디폴트값
	  if(parametric){
			center=mean(x);spread=sd(x)
	  }else{
			center=median(x);spread=mad(x)
	  }
	  if(print&parametric){
			cat("Mean=",center,"\n","SD=",spread,"\n")
	  }else if(print&!parametric){
			cat("Median=",center,"\n","MAD=",spread,"\n")
	  }
	  res=list(center=center,spread=spread)
	  return(res)
}

source("D:/민아/성민아/과제충 성민아/전산실습/prog2.R")

score=c(87,98,79,95,41,33,85)
res1=my_desc(x=score,print=TRUE)

res1

res2=my_desc(x=score,parametric=FALSE)
res2

<연습문제>

1)피보나치 수열(위에있음)

2)
my_plot=function(x,y){
		plot(y~x)
		abline(lm(y~x),col="black")
		abline(v=mean(x),col="red")
		abline(h=mean(y),col="blue")
}

with(cars,my_plot(dist,speed))


<7장 : 일변량 데이터의 정리>


7.1 일변량 범주형 데이터를 위한 그래프


7.1.1 막대그림

범주형 데이터에 대해 가장 많이 사용되는 그래프 중 하나
각 범주의 도수를 막대의 높이로 나타내는 그래프

막대그림 작성 1. barplot(height,...)
> height : 각 범주의 도수를 나타내는 벡터(table,도수분포표)
> 도수분포표 작성 : 함수 table()

막대그림 작성 2. plot(factor,...)
>factor : 요인

예제1) 요인에 대한 막대그림

state.region : 요인, 미국 50개 주를 지역범주로 구분

class(state.region)
state.region[1:5]
counts=table(state.region)
counts

>함수 table()로 작성된 객체 counts는 도수분포표

class(counts)

① 첫번째 방법 : 함수 barplot()

barplot(counts,main="Simple Bar Chart",xlab="Region",ylab="Frequency") #수직배열
barplot(counts,main="Horizontal Bar Chart",xlab="Frequency",ylab="Region",hori=T) #수평배열

② 두번째 방법 : 함수 plot()

plot(state.region,main="Simple Bar Chart",xlab="Region",ylab="Frequency")
plot(state.region,main="Horizontal Bar Chart",xlab="Frequency",ylab="Region",hori=T)

예제2) 숫자형 벡터에 대한 막대그림

데이터 프레임 mtcars : 1974년에 출간된 잡지 Motor Trend에서 추출된 32대 차량에 대한 11변수의 데이터
>변수 cly : 엔진의 실린더 갯수

attach(mtcars)
cyl
freq.cyl=table(cyl)
freq.cyl

>요인 함수가 아니므로 barplot()으로만 작성가능

barplot(freq.cyl,main="Simple Bar Chart",xlab="Number of Cylinder",ylab="Frequency",col="red")

막대그림의 각범주에 대한 라벨 수정
barplot(freq.cyl,main="Bar Chart with Different Bar Lables",
	xlab="Number of Cylinders",ylab="Frequency",col="red",
	names.arg=paste(c(4,6,8),"cylinder")) #arg1,arg2,... : 변수 이름


7.1.2 파이그림

범주형 데이터에 대한 그래프로 실생활에서 가장 많이 사용되는 그래프
각 범주의 상대도수에 비례한 면적으로 원을 나누어 나타내는 그래프

면적에 차이에 대하여 시각적으로 구분하는 것은 매우 어려움 -> 대부분의 통계학자들은 파이그림의 가치를 낮게 평가하고 있음

작성 : 함수 pie(x,lables=...)

x : 각 범주의 도수(도수분포표)
labels : 각 범주의 라벨

예제) state.region에 대한 파이그림

① 첫 번째 그림 : 기본 형태

counts=table(state.region)
region=names(counts)
region

pie(counts,labels=region,main="Simple pie Chart")
>각 조각의 면적에 대한 비교는 거의 불가능

② 두 번째 그림 : 각 조각의 상대 면적을 라벨로 추가

pct=round(100*counts/sum(counts))
region2=paste(region,"(",pct,"%)",sep="")
region2

pie(counts,labels=region2,col=rainbow(length(counts)),main="Pie Chart with Percentages")
>각 조각별 면적 차지 비율은 표기하였으나 여전히 번거로움이 존재

③ 세 번째 그림 : 3D 파이그림

작성 : 패키지 plotrix의 함수 pie3D()

install.packages("plotrix")
library(plotrix)

pie3D(counts,labels=region2,explode=0.1,main="3D pie Pie Chart") #옵션 explode : 조각간 간격
>시각적으로 화려한 그래프, 정보전달에 문제가 있다 / 가급적 사용을 자제하는 것이 바람직

④ 네 번째 그림 : Fan plot

작성 : 패키지 plotrix의 함수 fan.plot()

library(plotrix)

fan.plot(counts,labels=region2,main="Fan Plot")
>조각을 크기 순으로 배치
>조각의 반지를 조절로 모든 조각을 볼 수 있음
>조각의 면적 비교가 용이하다, 아직은 많이 사용되고 있지 않으나 파이그림보다 훨씬 효과적


※역사적 그래프 
F.Nightingale's Coxcomb -> 7단원 p.3(15)


7.1.3 점그림

Cleveland가 개발한 그래프
화려하게 치장할 수는 없으나 범주형 데이터의 속성을 잘 표현하는 그래프로 인정받는다

작성 : dotchart(x,lables=...)

x : 각 범주의 도수를 나타내는 숫자형 벡터
labels : 각 범주의 라벨

예제) state.region에 대한 점 그림

counts=table(state.region)
region=names(counts)

dotchart(counts,labels=region,main="Simple Dot Chats") #as.numeric으로 범주 자동 변환
> 객체 counts는 숫자형 벡터가 아니므로 경고 메시지 발생,

class(counts) #객체의 속성 확인 함수 class()사용
as.numeric(counts) #속성 변환

dotchart(as.numeric(counts),labels=region,main="Simple Dot Chart")


7.2 일변량 연속형 데이터를 위한 그래프


7.2.1 줄기-잎 그림

소규모의 데이터 분포에 적합한 그래프

작성 방법 : stem(x,scale=1)

x : 숫자형 벡터
scale : 그래프 길이 조절, 줄기 세분화 정도 지정

예제1) 데이터 프레임 women의 두 변수 분포

with(women,stem(height))

with(women,stem(weight))

예제2) 옵션 scale을 사용해야 하는 경우

x=c(20,31,33,52,12,70)
stem(x) #줄기의 간격이 세분화 되지 않아 자료의 값이 왜곡화 되어서 표현

stem(x,scale=2)


☆★7.2.2 상자그림

Box plot 혹은 Box-and-whiskers plot
단순한 형태의 그래프이나 데이터의 분포에 대한 많은 정보를 얻을 수 있다.

상자 작성 : 25% 백분위수, 중앙값, 75% 백분위수로 구성

Whisker 작성 : 상자에서 꼬리방향으로 그려지는 직선
>상자에서 최소값과 최대값까지 단순 연결
	상자의 길이(IQR)의 1.5배가 넘지 않은 관찰값까지 연결, 그 범위를 초과하는 관찰값은 점으로 표시(디폴트 방법)

작성 방법 : boxplot(x,range=1.5,horizontal=TRUE)

x : 숫자형 벡터
range : whisker를 IQR에 옵션 range의 값을 곱한 길이를 넘지 않는 관찰값까지 연결
horizontal : 상자그림의 방향

예제) 패키지 UsingR의 데이터 프레임 alltime.movies
: 2003년까지 미국에서 상영된 영화 중 총 수입이 가장 많았던 79개의 영하의 총수입(Gross)과
처음 상영된 년도(Release.Year)이 변수로 있고, 영화 제목은 행 이름으로 입력되어있음

총 수입의 상자그림 작성

install.packages("UsingR")
library(UsingR)
attach(alltime.movies)
boxplot(Gross,main="Simple Box Plot")

① 상자그림의 방향 및 whisker 길이 변경

boxplot(Gross,horizontal=T,main="Horizontal Box Plot")
boxplot(Gross,range=0,horizontal=T,main="Horizontal Box Plot with different whisker")
#range=0 : 최대, 최소값까지 수염표시

② boxplot()으로 생성되는 통계량

my_box=boxplot(Gross)
names(my_box)
my_box$stats #(좌측수염, Q1, Q2, Q3, 우측수염)
my_box$n #관찰지 갯수
my_box$conf #중위수 신뢰구간
my_box$out #이상치

☆★③ 상자그림에서 점으로 표시된 관찰값은 어떤 영화일까?

my_box=boxplot(Gross)
names(my_box)
my_box$out
rownames(alltime.movies)[Gross%in%my_box$out]

④ 범주형 상자그림

attach(mtcars)
boxplot(wt~vs)
detach(mtcars)


☆★7.2.3 히스토그램

연속형 데이터의 분포를 시각화하는데 가장 많이 사용되는 그래프

작성 방법 : hist(x,breaks="Sturges",freq=,...)

x : 숫자형 벡터
breaks : 구간 설정 방법
freq=T : 히스토그램의 높이가 빈도로 표시
freq=F : 히스토그램의 높이가 확률밀도로 표시, 전체 면적이 1로 조정

※구간 설정 방법(breaks)

1)각 구간을 나누는 점들로 이루어진 벡터
예 : breaks=seq(35,105,length=10)

2) 구간의 개수를 표시하는 하나의 숫자
예 : breaks=10

3) 구간의 개수를 계산하는 알고리즘을 칭하는 문자열
예 : "Sturges"(디폴트), "Scott", "FD"

예제) 데이터 프레임 faithful
> 미국 Yellowstone 국립공원에 있는 간헐천 Old Faithful의 분출지속시간(eruptions)과 분출간격(waiting)이 변수

① 분출간격(waiting)의 히스토그램

attach(faithful)
hist(waiting,main="Simple Histogram")

② 구간 설정에 따른 히스토그램의 형태 변화

hist(waiting,breaks=seq(40,100,length=6),col="red",main="")
hist(waiting,breaks=20,col="blue",main="")

※히스토그램의 문제

연속형 데이터의 분포를 계단형태로 나타냄으로 해서 발생하는 어색함
히스토그램의 태생적 한계
커널밀도추정 그림을 겹침으로 해서 어느정도 완화

hist(waiting,freq=FALSE,col="green",main="Histogram,rug plot,and density plot")
rug(waiting) #각 관찰값의 위치에 눈금표시
lines(density(waiting),col="red",lwd=2)
detach(faithful)


☆★7.2.4 커널밀도추정 그림 (Skip)


7.3.1 데이터 중심에 대한 요약통계

평균 : main()
중앙값 : median()
최빈값 : 연속형 데이터의 경우, 통계적으로는 큰 의미가 없는 통계량, R에서는 바로 계산해주는 함수X

예제) 데이터 프레임 faithful의 변수 waiting의 요약통계

attach(faithful)
mean(waiting)
median(waiting)

my_id=which(table(waiting)==max(table(waiting)))
#또는
my_id=which.max(table(waiting))

table(waiting)[my_id] #최빈값
detach(faithful)

예제 : 결측값이 있는 데이터, 데이터 프레임 airquality의 변수 Ozone의 요약통계

attach(airquality)
mean(Ozone);median(Ozone)
>결측값을 제거해야함, 옵션 na.rm=T

mean(Ozone,na.rm=T);median(Ozone,na.rm=T)
detach(airquality)

예제 : 좌측 혹은 우측으로 심하게 치우친 분포에 대한 요약
> 패키지 UsingR에 있는 데이터 프레임 cfb : 2001년 미국 소비자 재정상태에 관한 조사 데이터
> 변수 INCOME : 가구당 소득

library(UsingR)
attach(cfb)
mean(INCOME);median(INCOME)

> 평균값이 중앙값의 1.67배 : 우측으로 심하게 치우친 분포

변수 INCOME의 히스토그램

hist(INCOME,breaks=50,freq=F,main="Distribution of INCOME",ylim=c(0,1.5e-5),col="green")
lines(density(INCOME),col="blue",lwd=2)
rug(INCOME)

>로그 변환으로 좌우대칭의 분포형태로 변환 시도가 필요하다

☆★변수 INCOME의 로그변환

log_income=log(INCOME)
range(log_income)
range(INCOME)

> 양의 값을 갖고 있는 원 데이터가 변환 후 음수의 값을 가지고 있음
특히 -Inf의 값을 갖는 것이 문제이다

※ 로그변환의 특성 : 7단원 p.9(49)

0~1 사이의 값이 있는 데이터의 로그 변환방법

log1_income=log(INCOME+1)
range(log1_income)

로그 변환된 데이터의 분포

hist(log1_income,breaks=30,col="green",main="Distribution of Log(INCOME+1)")

mean(log1_income);median(log1_income)

>평균과 중위수가 비슷, 대칭적 분포 모형으로 변환


7.3.2 데이터 퍼짐에 대한 요약통계

데이터 중심에 대한 요약통계만으로는 데이터 분포에 대한 정확한 묘사가 불가능

데이터 퍼짐에 대한 요약 통계

1. 범위
2. 사분위범위
3. 표준편차와 분산

예제) 시험점수 모의 데이터

① 퍼짐에 대한 요약통계 1. 범위

범위 : 최대값-최소값
많은 수의 데이터 중 오직 두 값만을 이용하는 것으로 전체 데이터의 성격을 올바로 담아낼 수 없다

계산 방법 : diff(range(x))

test1=c(75,77,80,82,85,87,88)
test2=c(50,57,80,82,86,100,100)
range(test1);diff(range(test1))
range(test2);diff(range(test2))

② 퍼짐에 대한 요약통계 2. 사분위범위

p분위수 : 전체 데이터 중 100*p% 데이터보다는 크고 나무지 100*(1-p)%데이터보다는 작은 수, 단 p는 0보다 크고 1보다 작다
p백분위수 : 분위수와 동일한 개념, 단 p는 0보다 크고 100보다 작다
4분위수 : 전체 데이터를 크기 수능로 나열했을 때, 4등분하는 3개의 수를 의미하는 것으로, 25백분위수(Q1),중앙값,75백분위수(Q2)를 지칭
> 4분위범위 : Q3-Q1

1) 분위수 계산 : 함수 quantile()

기본적인 사용법 : quantile(x,prob=seq(0,1,by=0.25),...)

quantile(test1,prob=.25)
quantile(test2,prob=.25)
quantile(test1)
quantile(test2)

2) 사분위수 계산 : 함수 IQR()

IQR(test1)
quantile(test1,prob=.75)-quantile(test1,prob=.25)

IQR(test2)
quantile(test2,prob=.75)-quantile(test2,prob=.25)

③ 퍼짐에 대한 요약통계 3. 표준편차와 분산

가장 많이 사용되는 통계량
각 데이터들이 평균값에서부터 떨어진 거리를 이용하여 펴짐정도를 측정

표준편차 : 대략적으로 각 관찰값들이 평균값에서 떨어져있는 거리의 평균값

var(test1);var(test2)
sd(test1);sd(test2)

☆★ 함수 summary() : 일변량 데이터의 요약통계량 계산에 효과적으로 사용되는 함수

library(UsingR)
attach(cfb)
summary(INCOME)

예제) 평균값이 75백분위수와 매우 가까운 값, 실제 평균값은 몇 분위수에 해당하는가?

mean(INCOME<=mean(INCOME))

>평균값은 0.705분위수에 해당된다

함수 scale() : 데이터의 표준화

기본적인 사용법 : scale(x,center=T,scale=T)
> 디폴트 : center=sample mean, scale=sd


<연습문제>

문제 1.

1)
par(mfrow=c(1,1))

library(MASS)
attach(Cars93)
hist(EngineSize,main="Histograms of EngineSize",col="blue")
win.graph()
boxplot(EngineSize,main="Box plot of EngineSize",horizontal=T)
detach(Cars93)

2)
attach(Cars93)
my_box=boxplot(EngineSize)
names(my_box)
my_box$out

my_vars=c("Manufacturer","Model")
my_cases=which(EngineSize%in%my_box$out)
my_cases
Cars93[my_cases,my_vars]
detach(Cars93)

3)
attach(Cars93)
EngineSize
my_es=subset(Cars93,select=EngineSize,subset=(!EngineSize%in%my_box$out))
my_es$EngineSize
mean(my_es$EngineSize)
detach(Cars93)

4)
attach(Cars93)
cat.e=cut(EngineSize,breaks=c(min(EngineSize),1.6,2.0,max(EngineSize)),
include.lowest=T,right=T,labels=c("Small","Mid","Large"))
cat.e
t_cat.e=table(cat.e)
t_cat.e
 
barplot(t_cat.e)

pie(t_cat.e,col=c("red","green","blue"),labels=paste(names(t_cat.e),"(",round(t_cat.e/sum(t_cat.e)*100),"%)",sep=""))

dotchart(as.numeric(t_cat.e),labels=names(t_cat.e))


<족보 기출>

문제 1.
변수 x와 y를 비교하여 x가 y보다 클 때 Win, x가 y보다 작을 때 Lose, x와 y가 동일할 때 Draw를 출력하는 함수 생성

f1=function(x,y){
th="Draw"
if(x>y){th="Win"
}else if(x<y){th="Lose"}
return(th)
}
x=3;y=2;w=2
f1(x,y);fl(y,x);f1(y,w)

문제 2.
3x4행렬 A를 주어진 식과 같이 계산하라

A=matrix(c(9,7,1,3,3,5,9,1,1,3,8,2),ncol=3,byrow=T)
A
d=c(9,7,6)
solve(t(A)%*%rbind(3*diag(3),d))

문제 3.
벡터 x=(v1,v2,...,vn)이 주어졌을 때 1부터 n까지 모든 v에 대해서
(v1*v2)+(v2*v3)+...+(v(n-1)-vn)을 만족하는 함수 생성

fsp=function(x){
k=length(x)
sumpd=0
for(i in 1:(length(x)-1)){sumpd=sumpd+x[i]*x[i+1]}
return(sumpd)
}
x=c(5,3,1,3,7,5);fsp(x)

문제 4.
주어진 공간에 다음의 그래프 생성

attach(cars)
layout(matrix(c(0,1,2,1),nrow=2),heights=c(2,1),widths=c(1,2))
hist(speed);plot(dist~speed)
layout(matrix(1)) #par(mfrow=c(1,1)) 와 동일
detach(cars)

문제 5.
리스트 CO2의 변수 uptake의 평균에서 uptake중 변수 Type만을 선택한 것의 평균을 뺀 값 계산하기

mode(CO2)
attach(CO2)
mean(uptake)-tapply(uptake,Type,mean)
detach(CO2)

문제 6.
리스트 CO2의 변수 uptake에 대한 변수 Type이 Quebec인 관찰값에 대해서 상자그림을 그리고 이상값을 추출

attach(CO2)
kk=uptake[which(Type=="Quebec")]
aa=boxplot(kk)
aa$out

